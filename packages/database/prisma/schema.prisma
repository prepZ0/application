generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ============================================
// BETTER AUTH REQUIRED TABLES
// ============================================

model User {
  id            String    @id @default(cuid())
  name          String
  email         String    @unique
  emailVerified Boolean   @default(false)
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Custom fields
  phone          String?
  rollNumber     String?
  department     String?
  graduationYear Int?

  // Relations
  sessions         Session[]
  accounts         Account[]
  members          Member[]
  invitations      Invitation[]
  testAttempts     TestAttempt[]
  createdTests     Test[]     @relation("TestCreator")
  createdQuestions Question[] @relation("QuestionCreator")

  @@map("user")
}

model Session {
  id        String   @id @default(cuid())
  expiresAt DateTime
  token     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Custom: Test session lock
  activeTestAttemptId String?  @unique
  isTestLocked        Boolean  @default(false)

  @@map("session")
}

model Account {
  id                    String    @id @default(cuid())
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@map("account")
}

model Verification {
  id         String   @id @default(cuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@map("verification")
}

// ============================================
// BETTER AUTH ORGANIZATION TABLES (Colleges)
// ============================================

model Organization {
  id        String   @id @default(cuid())
  name      String
  slug      String   @unique
  logo      String?
  createdAt DateTime @default(now())
  metadata  String?

  // Custom college fields
  address      String?
  website      String?
  contactEmail String?
  isActive     Boolean @default(true)

  members     Member[]
  invitations Invitation[]
  tests       Test[]
  drives      Drive[]
  questions   Question[]

  @@map("organization")
}

model Member {
  id             String       @id @default(cuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  userId         String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  role           String
  createdAt      DateTime     @default(now())

  @@unique([organizationId, userId])
  @@map("member")
}

model Invitation {
  id             String       @id @default(cuid())
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  email          String
  role           String
  status         String       @default("pending")
  expiresAt      DateTime
  inviterId      String
  inviter        User         @relation(fields: [inviterId], references: [id], onDelete: Cascade)
  createdAt      DateTime     @default(now())

  @@map("invitation")
}

// ============================================
// APPLICATION TABLES
// ============================================

model Test {
  id           String     @id @default(cuid())
  title        String
  description  String?
  instructions String?

  // Configuration
  duration         Int
  passingScore     Int     @default(50)
  totalMarks       Int     @default(100)
  shuffleQuestions Boolean @default(false)
  showResults      Boolean @default(true)

  // Proctoring settings
  enableProctoring   Boolean @default(false)
  fullScreenRequired Boolean @default(true)
  tabSwitchLimit     Int     @default(3)

  // Status
  status      TestStatus @default(DRAFT)
  publishedAt DateTime?

  // Relations
  collegeId String
  college   Organization @relation(fields: [collegeId], references: [id], onDelete: Cascade)

  creatorId String
  creator   User   @relation("TestCreator", fields: [creatorId], references: [id])

  questions  TestQuestion[]
  driveTests DriveTest[]
  attempts   TestAttempt[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([collegeId])
  @@map("test")
}

enum TestStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

model Question {
  id         String       @id @default(cuid())
  type       QuestionType
  title      String
  content    String
  marks      Int          @default(1)
  difficulty Difficulty   @default(MEDIUM)
  tags       String[]

  // MCQ specific
  options Json?

  // Coding specific
  starterCode      Json?
  solution         String?
  testCases        Json?
  constraints      String?
  allowedLanguages String[] @default(["python", "java", "cpp", "c"])

  // Execution limits
  timeLimit   Int @default(2)
  memoryLimit Int @default(256)

  // Relations
  collegeId String
  college   Organization @relation(fields: [collegeId], references: [id], onDelete: Cascade)

  creatorId String
  creator   User   @relation("QuestionCreator", fields: [creatorId], references: [id])

  tests       TestQuestion[]
  submissions Submission[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([collegeId, type])
  @@map("question")
}

enum QuestionType {
  MCQ
  CODING
}

enum Difficulty {
  EASY
  MEDIUM
  HARD
}

model TestQuestion {
  id         String   @id @default(cuid())
  testId     String
  test       Test     @relation(fields: [testId], references: [id], onDelete: Cascade)
  questionId String
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  order      Int

  overrideMarks Int?

  @@unique([testId, questionId])
  @@index([testId, order])
  @@map("test_question")
}

model Drive {
  id          String  @id @default(cuid())
  title       String
  description String?
  companyName String
  companyLogo String?

  // Scheduling
  registrationStart DateTime
  registrationEnd   DateTime
  driveStart        DateTime
  driveEnd          DateTime

  // Eligibility
  eligibleDepartments String[]
  minCGPA             Float?
  graduationYears     Int[]

  // Status
  status DriveStatus @default(DRAFT)

  // Relations
  collegeId String
  college   Organization @relation(fields: [collegeId], references: [id], onDelete: Cascade)

  tests         DriveTest[]
  registrations DriveRegistration[]
  recruiters    DriveRecruiter[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([collegeId, status])
  @@map("drive")
}

enum DriveStatus {
  DRAFT
  REGISTRATION_OPEN
  REGISTRATION_CLOSED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

model DriveTest {
  id          String  @id @default(cuid())
  driveId     String
  drive       Drive   @relation(fields: [driveId], references: [id], onDelete: Cascade)
  testId      String
  test        Test    @relation(fields: [testId], references: [id], onDelete: Cascade)
  order       Int
  isMandatory Boolean @default(true)

  @@unique([driveId, testId])
  @@map("drive_test")
}

model DriveRegistration {
  id        String @id @default(cuid())
  driveId   String
  drive     Drive  @relation(fields: [driveId], references: [id], onDelete: Cascade)
  userId    String

  cgpa      Float?
  resumeUrl String?

  status RegistrationStatus @default(REGISTERED)

  createdAt DateTime @default(now())

  @@unique([driveId, userId])
  @@map("drive_registration")
}

enum RegistrationStatus {
  REGISTERED
  SHORTLISTED
  REJECTED
  SELECTED
  NOT_SELECTED
}

model DriveRecruiter {
  id          String   @id @default(cuid())
  driveId     String
  drive       Drive    @relation(fields: [driveId], references: [id], onDelete: Cascade)
  email       String
  accessToken String   @unique @default(cuid())
  expiresAt   DateTime

  createdAt DateTime @default(now())

  @@unique([driveId, email])
  @@map("drive_recruiter")
}

model TestAttempt {
  id     String @id @default(cuid())
  testId String
  test   Test   @relation(fields: [testId], references: [id], onDelete: Cascade)
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Timing
  startedAt   DateTime @default(now())
  submittedAt DateTime?
  endTime     DateTime

  // Status
  status AttemptStatus @default(IN_PROGRESS)

  // Results
  totalScore Float?
  percentage Float?
  passed     Boolean?

  // Proctoring data
  tabSwitchCount Int   @default(0)
  warnings       Json?

  submissions Submission[]

  @@unique([testId, userId])
  @@index([testId, status])
  @@map("test_attempt")
}

enum AttemptStatus {
  IN_PROGRESS
  SUBMITTED
  AUTO_SUBMITTED
  TERMINATED
  GRADED
}

model Submission {
  id            String      @id @default(cuid())
  testAttemptId String
  testAttempt   TestAttempt @relation(fields: [testAttemptId], references: [id], onDelete: Cascade)
  questionId    String
  question      Question    @relation(fields: [questionId], references: [id], onDelete: Cascade)

  // MCQ answer
  selectedOption String?

  // Coding answer
  code     String?
  language String?

  // Execution results
  executionResults Json?

  // Grading
  isCorrect Boolean?
  score     Float?
  gradedAt  DateTime?

  // Timestamps
  submittedAt DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([testAttemptId, questionId])
  @@index([testAttemptId])
  @@map("submission")
}

model ExecutionLog {
  id           String  @id @default(cuid())
  submissionId String?
  userId       String

  // Request
  language String
  code     String
  stdin    String?

  // Response
  stdout        String?
  stderr        String?
  exitCode      Int?
  executionTime Float?
  memoryUsed    Int?

  // Status
  status       ExecutionStatus
  errorMessage String?

  createdAt DateTime @default(now())

  @@index([userId, createdAt])
  @@map("execution_log")
}

enum ExecutionStatus {
  SUCCESS
  COMPILATION_ERROR
  RUNTIME_ERROR
  TIMEOUT
  MEMORY_LIMIT
  SYSTEM_ERROR
}
